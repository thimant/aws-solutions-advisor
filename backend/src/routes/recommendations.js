import express from 'express';
import { getRecommendations, getIndustries, getPainPoints } from '../services/knowledgeBaseService.js';
import { getServiceInfo } from '../data/awsServicesInfo.js';

const router = express.Router();

router.get('/industries', async (req, res) => {
  try {
    const data = await getIndustries();
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: 'Erro ao buscar ind√∫strias', details: error.message });
  }
});

router.get('/pain-points/:industry', async (req, res) => {
  try {
    const { industry } = req.params;
    const data = await getPainPoints(industry);
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: 'Erro ao buscar dores de neg√≥cio', details: error.message });
  }
});

router.post('/recommendations', async (req, res) => {
  try {
    const { industry, painPoints } = req.body;
    
    if (!industry || !painPoints || painPoints.length === 0) {
      return res.status(400).json({ error: 'Ind√∫stria e dores de neg√≥cio s√£o obrigat√≥rios' });
    }
    
    const data = await getRecommendations(industry, painPoints);
    res.json(data);
  } catch (error) {
    res.status(500).json({ error: 'Erro ao gerar recomenda√ß√µes', details: error.message });
  }
});

router.post('/service-info', async (req, res) => {
  try {
    const { serviceName, painPoint } = req.body;
    
    if (!serviceName) {
      return res.status(400).json({ error: 'Nome do servi√ßo √© obrigat√≥rio' });
    }
    
    const serviceInfo = getServiceInfo(serviceName);
    
    // Adiciona o motivo da recomenda√ß√£o
    const response = {
      ...serviceInfo,
      reason: `Este servi√ßo foi recomendado porque ajuda a resolver a dor: "${painPoint}". ${serviceInfo.description}`
    };
    
    res.json(response);
  } catch (error) {
    res.status(500).json({ error: 'Erro ao buscar informa√ß√µes do servi√ßo', details: error.message });
  }
});

router.post('/generate-architecture', async (req, res) => {
  try {
    const { services, title, painPoint } = req.body;
    
    if (!services || services.length === 0) {
      return res.status(400).json({ error: 'Lista de servi√ßos √© obrigat√≥ria' });
    }
    
    // Gerar diagrama Well-Architected
    const diagram = generateWellArchitectedDiagram(services, title);
    
    // Gerar recomenda√ß√µes baseadas nos 6 pilares do Well-Architected Framework
    const wellArchitectedPillars = generateWellArchitectedRecommendations(services);
    
    // Gerar descri√ß√£o e fluxo
    const architecture = {
      diagram: diagram,
      description: `Esta arquitetura de refer√™ncia utiliza ${services.length} servi√ßos AWS seguindo as melhores pr√°ticas do AWS Well-Architected Framework para resolver: "${painPoint}". A solu√ß√£o √© projetada com foco em excel√™ncia operacional, seguran√ßa, confiabilidade, efici√™ncia de performance, otimiza√ß√£o de custos e sustentabilidade.`,
      dataFlow: generateDataFlow(services),
      wellArchitected: wellArchitectedPillars,
      benefits: [
        'Arquitetura em camadas seguindo padr√µes de design AWS',
        'Escalabilidade horizontal e vertical',
        'Alta disponibilidade com Multi-AZ',
        'Recupera√ß√£o de desastres (DR) integrada',
        'Monitoramento proativo e observabilidade',
        'Seguran√ßa em profundidade (Defense in Depth)',
        'Otimiza√ß√£o de custos com Right Sizing'
      ],
      security: [
        'Criptografia de dados em tr√¢nsito (TLS 1.2+) e em repouso (AES-256)',
        'Princ√≠pio do menor privil√©gio com IAM',
        'Logs centralizados com CloudTrail e CloudWatch',
        'Prote√ß√£o contra DDoS com AWS Shield',
        'WAF para prote√ß√£o de aplica√ß√µes web',
        'Secrets Manager para credenciais',
        'VPC com subnets p√∫blicas e privadas',
        'Security Groups e NACLs configurados'
      ]
    };
    
    res.json(architecture);
  } catch (error) {
    res.status(500).json({ error: 'Erro ao gerar arquitetura', details: error.message });
  }
});

function getServiceIcon(serviceName) {
  const serviceIcons = {
    'Lambda': '‚ö°',
    'S3': 'üóÑÔ∏è',
    'DynamoDB': 'üî∑',
    'RDS': 'üóÉÔ∏è',
    'API Gateway': 'üö™',
    'CloudFront': 'üåê',
    'QuickSight': 'üìä',
    'Athena': 'üîç',
    'Redshift': 'üìà',
    'Kinesis': 'üåä',
    'SageMaker': 'ü§ñ',
    'IoT Core': 'üì°',
    'Greengrass': 'üîå',
    'WAF': 'üõ°Ô∏è',
    'GuardDuty': 'üëÅÔ∏è',
    'Shield': 'üî∞',
    'CloudWatch': 'üìâ',
    'SNS': 'üì¢',
    'SQS': 'üì¨',
    'EventBridge': 'üîî',
    'Step Functions': 'üîÑ',
    'ECS': 'üê≥',
    'EKS': '‚ò∏Ô∏è',
    'EC2': 'üíª',
    'VPC': 'üîí',
    'Route 53': 'üó∫Ô∏è',
    'Cognito': 'üë§',
    'Secrets Manager': 'üîê'
  };
  
  for (const [key, icon] of Object.entries(serviceIcons)) {
    if (serviceName.includes(key)) {
      return icon;
    }
  }
  return '‚òÅÔ∏è';
}

function generateWellArchitectedDiagram(services, title) {
  // Categorizar servi√ßos por camada
  const layers = {
    presentation: [],
    application: [],
    data: [],
    security: [],
    monitoring: [],
    networking: []
  };
  
  services.forEach(service => {
    if (service.includes('CloudFront') || service.includes('Route 53') || service.includes('API Gateway')) {
      layers.presentation.push(service);
    } else if (service.includes('Lambda') || service.includes('ECS') || service.includes('EKS') || service.includes('EC2') || service.includes('Step Functions')) {
      layers.application.push(service);
    } else if (service.includes('S3') || service.includes('DynamoDB') || service.includes('RDS') || service.includes('Redshift') || service.includes('Athena')) {
      layers.data.push(service);
    } else if (service.includes('WAF') || service.includes('Shield') || service.includes('GuardDuty') || service.includes('Cognito') || service.includes('Secrets Manager')) {
      layers.security.push(service);
    } else if (service.includes('CloudWatch') || service.includes('X-Ray')) {
      layers.monitoring.push(service);
    } else if (service.includes('VPC') || service.includes('PrivateLink')) {
      layers.networking.push(service);
    } else {
      layers.application.push(service);
    }
  });
  
  // Criar diagrama com arquitetura em camadas
  let diagram = 'graph TB\n';
  diagram += '    subgraph Internet["üåê Internet"]\n';
  diagram += '        User["üë§ Usu√°rio/Cliente"]\n';
  diagram += '    end\n\n';
  
  // Camada de Apresenta√ß√£o
  if (layers.presentation.length > 0) {
    diagram += '    subgraph Presentation["üì± Camada de Apresenta√ß√£o"]\n';
    layers.presentation.forEach((service, idx) => {
      const icon = getServiceIcon(service);
      const shortName = service.replace('Amazon ', '').replace('AWS ', '');
      diagram += `        P${idx}["${icon} ${shortName}"]\n`;
    });
    diagram += '    end\n\n';
  }
  
  // Camada de Aplica√ß√£o
  if (layers.application.length > 0) {
    diagram += '    subgraph Application["‚öôÔ∏è Camada de Aplica√ß√£o"]\n';
    layers.application.forEach((service, idx) => {
      const icon = getServiceIcon(service);
      const shortName = service.replace('Amazon ', '').replace('AWS ', '');
      diagram += `        A${idx}["${icon} ${shortName}"]\n`;
    });
    diagram += '    end\n\n';
  }
  
  // Camada de Dados
  if (layers.data.length > 0) {
    diagram += '    subgraph Data["üíæ Camada de Dados"]\n';
    layers.data.forEach((service, idx) => {
      const icon = getServiceIcon(service);
      const shortName = service.replace('Amazon ', '').replace('AWS ', '');
      diagram += `        D${idx}["${icon} ${shortName}"]\n`;
    });
    diagram += '    end\n\n';
  }
  
  // Camada de Seguran√ßa (cross-cutting)
  if (layers.security.length > 0) {
    diagram += '    subgraph Security["üîê Seguran√ßa"]\n';
    layers.security.forEach((service, idx) => {
      const icon = getServiceIcon(service);
      const shortName = service.replace('Amazon ', '').replace('AWS ', '');
      diagram += `        S${idx}["${icon} ${shortName}"]\n`;
    });
    diagram += '    end\n\n';
  }
  
  // Camada de Monitoramento (cross-cutting)
  if (layers.monitoring.length > 0) {
    diagram += '    subgraph Monitoring["üìä Monitoramento"]\n';
    layers.monitoring.forEach((service, idx) => {
      const icon = getServiceIcon(service);
      const shortName = service.replace('Amazon ', '').replace('AWS ', '');
      diagram += `        M${idx}["${icon} ${shortName}"]\n`;
    });
    diagram += '    end\n\n';
  }
  
  // Conex√µes
  diagram += '    User -->|HTTPS| ';
  if (layers.presentation.length > 0) {
    diagram += 'P0\n';
    if (layers.security.length > 0) {
      diagram += '    S0 -.->|Protege| P0\n';
    }
    if (layers.application.length > 0) {
      diagram += '    P0 --> A0\n';
    }
  } else if (layers.application.length > 0) {
    diagram += 'A0\n';
  }
  
  if (layers.application.length > 0 && layers.data.length > 0) {
    diagram += '    A0 --> D0\n';
  }
  
  if (layers.monitoring.length > 0) {
    if (layers.application.length > 0) {
      diagram += '    A0 -.->|Logs/M√©tricas| M0\n';
    }
    if (layers.data.length > 0) {
      diagram += '    D0 -.->|Logs/M√©tricas| M0\n';
    }
  }
  
  // Estilos
  diagram += '\n    classDef presentationStyle fill:#FF9900,stroke:#232F3E,stroke-width:2px,color:#000\n';
  diagram += '    classDef applicationStyle fill:#FF9900,stroke:#232F3E,stroke-width:2px,color:#000\n';
  diagram += '    classDef dataStyle fill:#3F8624,stroke:#232F3E,stroke-width:2px,color:#fff\n';
  diagram += '    classDef securityStyle fill:#DD344C,stroke:#232F3E,stroke-width:2px,color:#fff\n';
  diagram += '    classDef monitoringStyle fill:#8C4FFF,stroke:#232F3E,stroke-width:2px,color:#fff\n';
  
  return diagram;
}

function generateMermaidDiagram(services, title) {
  // Mapeamento de servi√ßos para √≠cones/emojis
  const serviceIcons = {
    'Lambda': '‚ö°',
    'S3': 'üóÑÔ∏è',
    'DynamoDB': 'üî∑',
    'RDS': 'üóÉÔ∏è',
    'API Gateway': 'üö™',
    'CloudFront': 'üåê',
    'QuickSight': 'üìä',
    'Athena': 'üîç',
    'Redshift': 'üìà',
    'Kinesis': 'üåä',
    'SageMaker': 'ü§ñ',
    'IoT Core': 'üì°',
    'Greengrass': 'üîå',
    'WAF': 'üõ°Ô∏è',
    'GuardDuty': 'üëÅÔ∏è',
    'Shield': 'üî∞',
    'CloudWatch': 'üìâ',
    'SNS': 'üì¢',
    'SQS': 'üì¨',
    'EventBridge': 'üîî',
    'Step Functions': 'üîÑ',
    'ECS': 'üê≥',
    'EKS': '‚ò∏Ô∏è',
    'EC2': 'üíª',
    'VPC': 'üîí',
    'Route 53': 'üó∫Ô∏è',
    'Cognito': 'üë§',
    'Secrets Manager': 'üîê'
  };
  
  function getServiceIcon(serviceName) {
    for (const [key, icon] of Object.entries(serviceIcons)) {
      if (serviceName.includes(key)) {
        return icon;
      }
    }
    return '‚òÅÔ∏è';
  }
  
  // Criar diagrama Mermaid com layout mais visual
  let diagram = 'graph LR\n';
  diagram += '    User["üë§<br/>Usu√°rio"]\n';
  
  services.forEach((service, index) => {
    const nodeId = `S${index}`;
    const icon = getServiceIcon(service);
    const shortName = service.replace('Amazon ', '').replace('AWS ', '');
    diagram += `    ${nodeId}["${icon}<br/>${shortName}"]\n`;
    
    if (index === 0) {
      diagram += `    User -->|Requisi√ß√£o| ${nodeId}\n`;
    } else {
      diagram += `    S${index - 1} -->|Dados| ${nodeId}\n`;
    }
  });
  
  diagram += '    S' + (services.length - 1) + ' -->|Resposta| Result["‚úÖ<br/>Resultado"]\n';
  
  // Adicionar estilos com cores AWS
  diagram += '    style User fill:#232F3E,stroke:#FF9900,stroke-width:3px,color:#fff\n';
  diagram += '    style Result fill:#1E8900,stroke:#FF9900,stroke-width:3px,color:#fff\n';
  
  services.forEach((service, index) => {
    const nodeId = `S${index}`;
    // Cores baseadas no tipo de servi√ßo
    if (service.includes('Lambda') || service.includes('API Gateway')) {
      diagram += `    style ${nodeId} fill:#FF9900,stroke:#232F3E,stroke-width:2px,color:#000\n`;
    } else if (service.includes('S3') || service.includes('DynamoDB') || service.includes('RDS')) {
      diagram += `    style ${nodeId} fill:#3F8624,stroke:#232F3E,stroke-width:2px,color:#fff\n`;
    } else if (service.includes('QuickSight') || service.includes('Athena') || service.includes('Redshift')) {
      diagram += `    style ${nodeId} fill:#8C4FFF,stroke:#232F3E,stroke-width:2px,color:#fff\n`;
    } else if (service.includes('SageMaker') || service.includes('AI') || service.includes('ML')) {
      diagram += `    style ${nodeId} fill:#01A88D,stroke:#232F3E,stroke-width:2px,color:#fff\n`;
    } else if (service.includes('WAF') || service.includes('Shield') || service.includes('GuardDuty')) {
      diagram += `    style ${nodeId} fill:#DD344C,stroke:#232F3E,stroke-width:2px,color:#fff\n`;
    } else {
      diagram += `    style ${nodeId} fill:#527FFF,stroke:#232F3E,stroke-width:2px,color:#fff\n`;
    }
  });
  
  return diagram;
}

function generateWellArchitectedRecommendations(services) {
  const pillars = {
    operational: {
      title: 'üîß Excel√™ncia Operacional',
      recommendations: [
        'Implementar Infrastructure as Code (IaC) com CloudFormation ou Terraform',
        'Automatizar deploys com CI/CD (CodePipeline, CodeBuild)',
        'Usar tags para organiza√ß√£o e rastreamento de recursos',
        'Implementar runbooks e playbooks para opera√ß√µes comuns'
      ]
    },
    security: {
      title: 'üîê Seguran√ßa',
      recommendations: [
        'Habilitar MFA para todos os usu√°rios IAM',
        'Usar AWS Organizations para governan√ßa multi-conta',
        'Implementar AWS Config para auditoria de conformidade',
        'Rotacionar credenciais regularmente com Secrets Manager'
      ]
    },
    reliability: {
      title: 'üõ°Ô∏è Confiabilidade',
      recommendations: [
        'Distribuir recursos em m√∫ltiplas Availability Zones',
        'Implementar health checks e auto-healing',
        'Configurar backups autom√°ticos e testes de recupera√ß√£o',
        'Usar Route 53 para failover autom√°tico'
      ]
    },
    performance: {
      title: '‚ö° Efici√™ncia de Performance',
      recommendations: [
        'Usar CloudFront para cache e distribui√ß√£o global',
        'Implementar ElastiCache para cache de dados',
        'Otimizar queries de banco de dados',
        'Usar inst√¢ncias apropriadas para cada workload'
      ]
    },
    cost: {
      title: 'üí∞ Otimiza√ß√£o de Custos',
      recommendations: [
        'Implementar Auto Scaling para ajustar capacidade',
        'Usar Reserved Instances ou Savings Plans',
        'Configurar AWS Budgets e Cost Anomaly Detection',
        'Revisar e remover recursos n√£o utilizados'
      ]
    },
    sustainability: {
      title: 'üå± Sustentabilidade',
      recommendations: [
        'Usar regi√µes AWS com energia renov√°vel',
        'Otimizar utiliza√ß√£o de recursos para reduzir pegada de carbono',
        'Implementar arquitetura serverless quando poss√≠vel',
        'Usar inst√¢ncias Graviton para melhor efici√™ncia energ√©tica'
      ]
    }
  };
  
  // Adicionar recomenda√ß√µes espec√≠ficas baseadas nos servi√ßos
  if (services.some(s => s.includes('Lambda'))) {
    pillars.cost.recommendations.push('Otimizar mem√≥ria e timeout do Lambda para reduzir custos');
    pillars.sustainability.recommendations.push('Lambda j√° √© serverless - excelente para sustentabilidade');
  }
  
  if (services.some(s => s.includes('RDS') || s.includes('DynamoDB'))) {
    pillars.reliability.recommendations.push('Habilitar backups autom√°ticos e Point-in-Time Recovery');
    pillars.performance.recommendations.push('Usar Read Replicas para distribuir carga de leitura');
  }
  
  if (services.some(s => s.includes('S3'))) {
    pillars.cost.recommendations.push('Usar S3 Intelligent-Tiering para otimiza√ß√£o autom√°tica');
    pillars.security.recommendations.push('Habilitar S3 Block Public Access e versionamento');
  }
  
  return pillars;
}

function generateDataFlow(services) {
  const flow = [
    'Usu√°rio acessa a aplica√ß√£o atrav√©s da interface',
  ];
  
  services.forEach((service, index) => {
    if (service.includes('API Gateway') || service.includes('Lambda')) {
      flow.push(`${service} processa as requisi√ß√µes de forma serverless`);
    } else if (service.includes('S3')) {
      flow.push(`${service} armazena dados de forma dur√°vel e escal√°vel`);
    } else if (service.includes('DynamoDB') || service.includes('RDS')) {
      flow.push(`${service} gerencia o armazenamento de dados transacionais`);
    } else if (service.includes('CloudFront')) {
      flow.push(`${service} distribui conte√∫do globalmente com baixa lat√™ncia`);
    } else if (service.includes('QuickSight') || service.includes('Athena')) {
      flow.push(`${service} fornece an√°lises e insights dos dados`);
    } else {
      flow.push(`${service} processa e transforma os dados`);
    }
  });
  
  flow.push('Resultado √© entregue ao usu√°rio de forma segura e eficiente');
  
  return flow;
}

export default router;
